name: CD Release (Windows)

on:
    push:
        tags:
            - "v*"
    workflow_dispatch:

permissions:
    contents: write
    packages: write

concurrency:
    group: release-${{ github.ref }}
    cancel-in-progress: false

jobs:
    windows-release:
        name: Release (download CI artifact + GitHub Release + Windows Docker)
        environment: secrets
        runs-on: windows-2022

        steps:
            # 1) Checkout repo (needed for Docker build context)
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  submodules: recursive

            # 2) Download the Windows artifact produced by CI for the same commit as the tag
            - name: Download Windows artifact from CI (same commit)
              uses: dawidd6/action-download-artifact@v3
              with:
                  workflow: ci.yml
                  commit: ${{ github.sha }}
                  name: falcata-win64
                  path: artifact
                  if_no_artifact_found: fail

            - name: Show downloaded files
              shell: pwsh
              run: |
                  Get-ChildItem artifact -Recurse | Select-Object FullName, Length

            # 3) Prepare a deterministic release zip (handles both: zip present OR raw files present)
            - name: Build release zip (dist -> Falcata-<tag>-win64.zip)
              shell: pwsh
              run: |
                  $tag = "${{ github.ref_name }}"

                  New-Item -ItemType Directory -Force dist | Out-Null

                  # Case A: CI artifact contains a zip (your CI usually uploads Falcata-win64.zip)
                  $zip = Get-ChildItem artifact -Recurse -Filter *.zip -ErrorAction SilentlyContinue | Select-Object -First 1
                  if ($zip) {
                    Write-Host "Found zip in artifact: $($zip.FullName)"
                    Expand-Archive -Path $zip.FullName -DestinationPath dist -Force
                  }
                  else {
                    # Case B: CI artifact contains files directly (no zip) => copy them into dist
                    Write-Host "No zip found in artifact/. Copying artifact content into dist/..."
                    Copy-Item -Path "artifact\*" -Destination "dist\" -Recurse -Force
                  }

                  Write-Host "dist content:"
                  Get-ChildItem dist -Recurse | Select-Object FullName, Length

                  # Must contain WebServer.exe somewhere
                  $exe = Get-ChildItem dist -Recurse -Filter WebServer.exe -ErrorAction SilentlyContinue | Select-Object -First 1
                  if (-not $exe) { throw "WebServer.exe not found inside dist/. Ensure CI artifact includes WebServer.exe (or zip containing it)." }

                  # Normalize: ensure WebServer.exe at dist root (optional but convenient)
                  if ($exe.FullName -ne (Join-Path (Resolve-Path dist) "WebServer.exe")) {
                    Copy-Item $exe.FullName -Destination "dist\WebServer.exe" -Force
                  }

                  # Create final release zip
                  $outZip = "Falcata-$tag-win64.zip"
                  if (Test-Path $outZip) { Remove-Item $outZip -Force }
                  Compress-Archive -Path "dist\*" -DestinationPath $outZip -Force
                  Write-Host "Created: $outZip"

            # 4) Create GitHub Release + upload the Windows zip asset
            - name: Create GitHub Release + upload asset
              uses: softprops/action-gh-release@v2
              with:
                  generate_release_notes: true
                  files: |
                      Falcata-${{ github.ref_name }}-win64.zip

            # 5) Login to GHCR
            - name: Login to GHCR
              uses: docker/login-action@v3
              with:
                  registry: ghcr.io
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            # 6) Build + push Windows container image
            # IMPORTANT: you need a Windows Dockerfile (example name: Dockerfile.windows)
            - name: Build & push Windows Docker image
              shell: pwsh
              run: |
                  $image = ("ghcr.io/${{ github.repository }}").ToLower()
                  $tag   = "${{ github.ref_name }}"

                  if (-not (Test-Path "Dockerfile.windows")) {
                    throw "Dockerfile.windows is missing. Add it at repo root to build a Windows container."
                  }

                  $image = ("ghcr.io/${{ github.repository }}").ToLower()
                  $tag   = "${{ github.ref_name }}"

                  docker version

                  docker build -f Dockerfile.windows `
                    -t "${image}:${tag}-windows" `
                    -t "${image}:windows-latest" `
                    .

                  docker push "${image}:${tag}-windows"
                  docker push "${image}:windows-latest"

            - name: Deploy via SSH (docker compose pull + up)
              if: ${{ vars.DEPLOY_HOST != '' }}
              shell: pwsh
              env:
                  DEPLOY_HOST: ${{ vars.DEPLOY_HOST }}
                  DEPLOY_PATH: ${{ vars.DEPLOY_PATH }}
                  DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
                  DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
              run: |
                  $ErrorActionPreference = "Stop"

                  $keyPath = Join-Path $env:RUNNER_TEMP "deploy_key"
                  Set-Content -Path $keyPath -Value $env:DEPLOY_SSH_KEY -NoNewline

                  # Lock down key permissions (Windows)
                  icacls $keyPath /inheritance:r | Out-Null
                  icacls $keyPath /grant:r "$($env:USERNAME):(R)" | Out-Null

                  $host = $env:DEPLOY_HOST
                  $user = $env:DEPLOY_USER
                  $path = $env:DEPLOY_PATH

                  ssh -o StrictHostKeyChecking=no -i $keyPath "$user@$host" "cd `"$path`" && docker compose pull && docker compose up -d --remove-orphans"
